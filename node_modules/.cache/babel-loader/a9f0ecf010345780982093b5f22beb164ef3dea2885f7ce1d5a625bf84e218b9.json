{"ast":null,"code":"/**\n * File Scanner Service\n * Scans a folder and retrieves information about all .txt files\n */\n\nclass FileScannerService {\n  /**\n   * Scans a folder and returns information about all .txt files\n   * @param {string} folderPath - The path to the folder to scan\n   * @returns {Promise<Object>} JSON object containing file information\n   */\n  static async scanTextFiles(folderPath) {\n    try {\n      // Validate folder path\n      if (!folderPath || typeof folderPath !== 'string') {\n        throw new Error('Invalid folder path provided');\n      }\n\n      // Ensure folder path ends with slash\n      const normalizedPath = folderPath.endsWith('/') ? folderPath : folderPath + '/';\n\n      // Get text files from the folder\n      const files = await FileScannerService.getTextFilesFromFolder(normalizedPath);\n      return {\n        success: true,\n        data: {\n          folderPath: normalizedPath,\n          totalFiles: files.length,\n          files: files,\n          scanTimestamp: new Date().toISOString()\n        },\n        metadata: {\n          scanMethod: 'folder-scan',\n          environment: 'browser'\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          type: error.name,\n          timestamp: new Date().toISOString()\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Gets text files from a folder using a predefined list or server endpoint\n   * @param {string} folderPath - The folder path\n   * @returns {Promise<Array>} Array of file information objects\n   */\n  static async getTextFilesFromFolder(folderPath) {\n    // For browser environments, we'll use a predefined list or fetch from a manifest\n    const knownTextFiles = [{\n      path: `${folderPath}example.txt`,\n      title: 'Example Text File',\n      info: 'Sample text file for testing the TextFileReaderService'\n    }];\n\n    // Try to get additional files from a manifest\n    try {\n      const manifestResponse = await fetch(`${folderPath}file-manifest.json`);\n      if (manifestResponse.ok) {\n        var _manifest$textFiles, _manifest$textFiles2;\n        const manifest = await manifestResponse.json();\n        console.log('üìÅ Loaded manifest with', ((_manifest$textFiles = manifest.textFiles) === null || _manifest$textFiles === void 0 ? void 0 : _manifest$textFiles.length) || 0, 'files');\n\n        // Filter out non-story files (README, documentation, etc.)\n        const storyFiles = ((_manifest$textFiles2 = manifest.textFiles) === null || _manifest$textFiles2 === void 0 ? void 0 : _manifest$textFiles2.filter(file => {\n          const fileName = file.path.toLowerCase();\n\n          // Only exclude files that are clearly documentation/README\n          return !fileName.includes('readme') && !fileName.includes('manifest') && !fileName.includes('license') && !fileName.includes('changelog') && !fileName.includes('contributing') && file.path.toLowerCase().endsWith('.txt');\n        })) || [];\n        return storyFiles.length > 0 ? storyFiles : knownTextFiles;\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Could not fetch file manifest, using default list');\n    }\n    return knownTextFiles;\n  }\n\n  /**\n   * Gets detailed information about a specific text file\n   * @param {string} filePath - Path to the text file\n   * @returns {Promise<Object>} Detailed file information\n   */\n  static async getFileInfo(filePath) {\n    try {\n      if (!filePath || typeof filePath !== 'string') {\n        throw new Error('Invalid file path provided');\n      }\n      if (!filePath.toLowerCase().endsWith('.txt')) {\n        throw new Error('File must have .txt extension');\n      }\n\n      // Get file content for analysis\n      const contentResponse = await fetch(filePath);\n      if (!contentResponse.ok) {\n        throw new Error(`Failed to access file: ${contentResponse.status} ${contentResponse.statusText}`);\n      }\n      const content = await contentResponse.text();\n\n      // Extract title from first line or filename\n      const lines = content.split('\\n');\n      const firstLine = lines[0].trim();\n      const fileName = filePath.split('/').pop().replace('.txt', '');\n\n      // Try to extract title from first line if it looks like a title\n      const title = FileScannerService.extractTitle(firstLine, fileName);\n\n      // Generate info from content analysis\n      const info = FileScannerService.generateFileInfo(content, fileName);\n      return {\n        success: true,\n        data: {\n          path: filePath,\n          title: title,\n          info: info,\n          fileName: fileName,\n          fileSize: content.length,\n          lineCount: lines.length,\n          wordCount: content.trim().split(/\\s+/).filter(word => word.length > 0).length,\n          characterCount: content.length,\n          firstLine: firstLine,\n          content: content,\n          timestamp: new Date().toISOString()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          type: error.name,\n          timestamp: new Date().toISOString()\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Extracts a title from the first line or filename\n   * @param {string} firstLine - First line of the file\n   * @param {string} fileName - Name of the file without extension\n   * @returns {string} Extracted title\n   */\n  static extractTitle(firstLine, fileName) {\n    // If first line looks like a title (not too long, starts with capital, no special chars)\n    if (firstLine && firstLine.length < 100 && firstLine.length > 0 && /^[A-Z]/.test(firstLine) && !firstLine.includes('http') && !firstLine.includes('www')) {\n      return firstLine;\n    }\n\n    // Otherwise use filename converted to title case\n    return fileName.split(/[-_\\s]+/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n  }\n\n  /**\n   * Generates file information based on content analysis\n   * @param {string} content - File content\n   * @param {string} fileName - File name\n   * @returns {string} Generated file information\n   */\n  static generateFileInfo(content, fileName) {\n    const lines = content.split('\\n');\n    const words = content.trim().split(/\\s+/).filter(word => word.length > 0);\n    let info = '';\n    if (lines.length <= 1) {\n      info = 'Single line text file';\n    } else if (lines.length <= 10) {\n      info = `Short story with ${lines.length} lines`;\n    } else if (lines.length <= 50) {\n      info = `Medium story with ${lines.length} lines`;\n    } else {\n      info = `Long story with ${lines.length} lines`;\n    }\n    info += ` (${words.length} words)`;\n\n    // Add content type hints\n    if (content.includes('http') || content.includes('www')) {\n      info += ' - Contains links';\n    }\n    if (content.includes('@')) {\n      info += ' - Contains email addresses';\n    }\n    if (content.match(/\\d{4}-\\d{2}-\\d{2}/)) {\n      info += ' - Contains dates';\n    }\n    return info;\n  }\n}\n\n// Export the service\nexport default FileScannerService;\n\n// Also export individual methods for convenience\nexport const {\n  scanTextFiles,\n  getFileInfo\n} = FileScannerService;","map":{"version":3,"names":["FileScannerService","scanTextFiles","folderPath","Error","normalizedPath","endsWith","files","getTextFilesFromFolder","success","data","totalFiles","length","scanTimestamp","Date","toISOString","metadata","scanMethod","environment","error","message","type","name","timestamp","knownTextFiles","path","title","info","manifestResponse","fetch","ok","_manifest$textFiles","_manifest$textFiles2","manifest","json","console","log","textFiles","storyFiles","filter","file","fileName","toLowerCase","includes","warn","getFileInfo","filePath","contentResponse","status","statusText","content","text","lines","split","firstLine","trim","pop","replace","extractTitle","generateFileInfo","fileSize","lineCount","wordCount","word","characterCount","test","map","charAt","toUpperCase","slice","join","words","match"],"sources":["/Users/verseofthesun/Web/verseofthesun/src/StoryTxt/StoryService/FileScannerService.js"],"sourcesContent":["/**\n * File Scanner Service\n * Scans a folder and retrieves information about all .txt files\n */\n\nclass FileScannerService {\n  /**\n   * Scans a folder and returns information about all .txt files\n   * @param {string} folderPath - The path to the folder to scan\n   * @returns {Promise<Object>} JSON object containing file information\n   */\n  static async scanTextFiles(folderPath) {\n    try {\n      // Validate folder path\n      if (!folderPath || typeof folderPath !== 'string') {\n        throw new Error('Invalid folder path provided');\n      }\n\n      // Ensure folder path ends with slash\n      const normalizedPath = folderPath.endsWith('/') ? folderPath : folderPath + '/';\n\n      // Get text files from the folder\n      const files = await FileScannerService.getTextFilesFromFolder(normalizedPath);\n\n      return {\n        success: true,\n        data: {\n          folderPath: normalizedPath,\n          totalFiles: files.length,\n          files: files,\n          scanTimestamp: new Date().toISOString()\n        },\n        metadata: {\n          scanMethod: 'folder-scan',\n          environment: 'browser'\n        }\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          type: error.name,\n          timestamp: new Date().toISOString()\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Gets text files from a folder using a predefined list or server endpoint\n   * @param {string} folderPath - The folder path\n   * @returns {Promise<Array>} Array of file information objects\n   */\n  static async getTextFilesFromFolder(folderPath) {\n    // For browser environments, we'll use a predefined list or fetch from a manifest\n    const knownTextFiles = [\n      {\n        path: `${folderPath}example.txt`,\n        title: 'Example Text File',\n        info: 'Sample text file for testing the TextFileReaderService'\n      }\n    ];\n\n    // Try to get additional files from a manifest\n    try {\n      const manifestResponse = await fetch(`${folderPath}file-manifest.json`);\n      if (manifestResponse.ok) {\n        const manifest = await manifestResponse.json();\n        console.log('üìÅ Loaded manifest with', manifest.textFiles?.length || 0, 'files');\n        \n        // Filter out non-story files (README, documentation, etc.)\n        const storyFiles = manifest.textFiles?.filter(file => {\n          const fileName = file.path.toLowerCase();\n          \n          // Only exclude files that are clearly documentation/README\n          return !fileName.includes('readme') && \n                 !fileName.includes('manifest') &&\n                 !fileName.includes('license') &&\n                 !fileName.includes('changelog') &&\n                 !fileName.includes('contributing') &&\n                 file.path.toLowerCase().endsWith('.txt');\n        }) || [];\n        \n        return storyFiles.length > 0 ? storyFiles : knownTextFiles;\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Could not fetch file manifest, using default list');\n    }\n\n    return knownTextFiles;\n  }\n\n  /**\n   * Gets detailed information about a specific text file\n   * @param {string} filePath - Path to the text file\n   * @returns {Promise<Object>} Detailed file information\n   */\n  static async getFileInfo(filePath) {\n    try {\n      if (!filePath || typeof filePath !== 'string') {\n        throw new Error('Invalid file path provided');\n      }\n\n      if (!filePath.toLowerCase().endsWith('.txt')) {\n        throw new Error('File must have .txt extension');\n      }\n\n      // Get file content for analysis\n      const contentResponse = await fetch(filePath);\n      if (!contentResponse.ok) {\n        throw new Error(`Failed to access file: ${contentResponse.status} ${contentResponse.statusText}`);\n      }\n      \n      const content = await contentResponse.text();\n\n      // Extract title from first line or filename\n      const lines = content.split('\\n');\n      const firstLine = lines[0].trim();\n      const fileName = filePath.split('/').pop().replace('.txt', '');\n      \n      // Try to extract title from first line if it looks like a title\n      const title = FileScannerService.extractTitle(firstLine, fileName);\n\n      // Generate info from content analysis\n      const info = FileScannerService.generateFileInfo(content, fileName);\n\n      return {\n        success: true,\n        data: {\n          path: filePath,\n          title: title,\n          info: info,\n          fileName: fileName,\n          fileSize: content.length,\n          lineCount: lines.length,\n          wordCount: content.trim().split(/\\s+/).filter(word => word.length > 0).length,\n          characterCount: content.length,\n          firstLine: firstLine,\n          content: content,\n          timestamp: new Date().toISOString()\n        }\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          type: error.name,\n          timestamp: new Date().toISOString()\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Extracts a title from the first line or filename\n   * @param {string} firstLine - First line of the file\n   * @param {string} fileName - Name of the file without extension\n   * @returns {string} Extracted title\n   */\n  static extractTitle(firstLine, fileName) {\n    // If first line looks like a title (not too long, starts with capital, no special chars)\n    if (firstLine && \n        firstLine.length < 100 && \n        firstLine.length > 0 &&\n        /^[A-Z]/.test(firstLine) &&\n        !firstLine.includes('http') &&\n        !firstLine.includes('www')) {\n      return firstLine;\n    }\n    \n    // Otherwise use filename converted to title case\n    return fileName\n      .split(/[-_\\s]+/)\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  }\n\n  /**\n   * Generates file information based on content analysis\n   * @param {string} content - File content\n   * @param {string} fileName - File name\n   * @returns {string} Generated file information\n   */\n  static generateFileInfo(content, fileName) {\n    const lines = content.split('\\n');\n    const words = content.trim().split(/\\s+/).filter(word => word.length > 0);\n    \n    let info = '';\n    \n    if (lines.length <= 1) {\n      info = 'Single line text file';\n    } else if (lines.length <= 10) {\n      info = `Short story with ${lines.length} lines`;\n    } else if (lines.length <= 50) {\n      info = `Medium story with ${lines.length} lines`;\n    } else {\n      info = `Long story with ${lines.length} lines`;\n    }\n    \n    info += ` (${words.length} words)`;\n    \n    // Add content type hints\n    if (content.includes('http') || content.includes('www')) {\n      info += ' - Contains links';\n    }\n    if (content.includes('@')) {\n      info += ' - Contains email addresses';\n    }\n    if (content.match(/\\d{4}-\\d{2}-\\d{2}/)) {\n      info += ' - Contains dates';\n    }\n    \n    return info;\n  }\n}\n\n// Export the service\nexport default FileScannerService;\n\n// Also export individual methods for convenience\nexport const { \n  scanTextFiles, \n  getFileInfo\n} = FileScannerService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}