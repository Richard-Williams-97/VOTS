{"ast":null,"code":"/**\n * File Scanner Service\n * Scans a folder and retrieves information about all .txt files\n */\n\nclass FileScannerService {\n  /**\n   * Scans a folder and returns information about all .txt files\n   * @param {string} folderPath - The path to the folder to scan\n   * @returns {Promise<Object>} JSON object containing file information\n   */\n  static async scanTextFiles(folderPath) {\n    try {\n      // Validate folder path\n      if (!folderPath || typeof folderPath !== 'string') {\n        throw new Error('Invalid folder path provided');\n      }\n\n      // Ensure folder path ends with slash\n      const normalizedPath = folderPath.endsWith('/') ? folderPath : folderPath + '/';\n\n      // Get text files from the folder\n      const files = await FileScannerService.getTextFilesFromFolder(normalizedPath);\n      return {\n        success: true,\n        data: {\n          folderPath: normalizedPath,\n          totalFiles: files.length,\n          files: files,\n          scanTimestamp: new Date().toISOString()\n        },\n        metadata: {\n          scanMethod: 'folder-scan',\n          environment: 'browser'\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          type: error.name,\n          timestamp: new Date().toISOString()\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Gets text files from a folder using a predefined list or server endpoint\n   * @param {string} folderPath - The folder path\n   * @returns {Promise<Array>} Array of file information objects\n   */\n  static async getTextFilesFromFolder(folderPath) {\n    // For browser environments, we'll use a predefined list or fetch from a manifest\n    const knownTextFiles = [{\n      path: `${folderPath}example.txt`,\n      title: 'Example Text File',\n      info: 'Sample text file for testing the TextFileReaderService'\n    }, {\n      path: `${folderPath}README.txt`,\n      title: 'README File',\n      info: 'Project documentation and setup instructions'\n    }];\n\n    // Try to get additional files from a manifest\n    try {\n      const manifestResponse = await fetch(`${folderPath}file-manifest.json`);\n      if (manifestResponse.ok) {\n        const manifest = await manifestResponse.json();\n        return manifest.textFiles || knownTextFiles;\n      }\n    } catch (error) {\n      console.warn('Could not fetch file manifest, using default list');\n    }\n    return knownTextFiles;\n  }\n\n  /**\n   * Gets detailed information about a specific text file\n   * @param {string} filePath - Path to the text file\n   * @returns {Promise<Object>} Detailed file information\n   */\n  static async getFileInfo(filePath) {\n    try {\n      if (!filePath || typeof filePath !== 'string') {\n        throw new Error('Invalid file path provided');\n      }\n      if (!filePath.toLowerCase().endsWith('.txt')) {\n        throw new Error('File must have .txt extension');\n      }\n\n      // Get file content for analysis\n      const contentResponse = await fetch(filePath);\n      if (!contentResponse.ok) {\n        throw new Error(`Failed to access file: ${contentResponse.status} ${contentResponse.statusText}`);\n      }\n      const content = await contentResponse.text();\n\n      // Extract title from first line or filename\n      const lines = content.split('\\n');\n      const firstLine = lines[0].trim();\n      const fileName = filePath.split('/').pop().replace('.txt', '');\n\n      // Try to extract title from first line if it looks like a title\n      const title = this.extractTitle(firstLine, fileName);\n\n      // Generate info from content analysis\n      const info = this.generateFileInfo(content, fileName);\n      return {\n        success: true,\n        data: {\n          path: filePath,\n          title: title,\n          info: info,\n          fileName: fileName,\n          fileSize: content.length,\n          lineCount: lines.length,\n          wordCount: content.trim().split(/\\s+/).filter(word => word.length > 0).length,\n          characterCount: content.length,\n          firstLine: firstLine,\n          content: content,\n          timestamp: new Date().toISOString()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          type: error.name,\n          timestamp: new Date().toISOString()\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Extracts a title from the first line or filename\n   * @param {string} firstLine - First line of the file\n   * @param {string} fileName - Name of the file without extension\n   * @returns {string} Extracted title\n   */\n  static extractTitle(firstLine, fileName) {\n    // If first line looks like a title (not too long, starts with capital, no special chars)\n    if (firstLine && firstLine.length < 100 && firstLine.length > 0 && /^[A-Z]/.test(firstLine) && !firstLine.includes('http') && !firstLine.includes('www')) {\n      return firstLine;\n    }\n\n    // Otherwise use filename converted to title case\n    return fileName.split(/[-_\\s]+/).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n  }\n\n  /**\n   * Generates file information based on content analysis\n   * @param {string} content - File content\n   * @param {string} fileName - File name\n   * @returns {string} Generated file information\n   */\n  static generateFileInfo(content, fileName) {\n    const lines = content.split('\\n');\n    const words = content.trim().split(/\\s+/).filter(word => word.length > 0);\n    let info = '';\n    if (lines.length <= 1) {\n      info = 'Single line text file';\n    } else if (lines.length <= 10) {\n      info = `Short story with ${lines.length} lines`;\n    } else if (lines.length <= 50) {\n      info = `Medium story with ${lines.length} lines`;\n    } else {\n      info = `Long story with ${lines.length} lines`;\n    }\n    info += ` (${words.length} words)`;\n\n    // Add content type hints\n    if (content.includes('http') || content.includes('www')) {\n      info += ' - Contains links';\n    }\n    if (content.includes('@')) {\n      info += ' - Contains email addresses';\n    }\n    if (content.match(/\\d{4}-\\d{2}-\\d{2}/)) {\n      info += ' - Contains dates';\n    }\n    return info;\n  }\n}\n\n// Export the service\nexport default FileScannerService;\n\n// Also export individual methods for convenience\nexport const {\n  scanTextFiles,\n  getFileInfo\n} = FileScannerService;","map":{"version":3,"names":["FileScannerService","scanTextFiles","folderPath","Error","normalizedPath","endsWith","files","getTextFilesFromFolder","success","data","totalFiles","length","scanTimestamp","Date","toISOString","metadata","scanMethod","environment","error","message","type","name","timestamp","knownTextFiles","path","title","info","manifestResponse","fetch","ok","manifest","json","textFiles","console","warn","getFileInfo","filePath","toLowerCase","contentResponse","status","statusText","content","text","lines","split","firstLine","trim","fileName","pop","replace","extractTitle","generateFileInfo","fileSize","lineCount","wordCount","filter","word","characterCount","test","includes","map","charAt","toUpperCase","slice","join","words","match"],"sources":["/Users/verseofthesun/Web/verseofthesun/src/StoryTxt/StoryService/FileScannerService.js"],"sourcesContent":["/**\n * File Scanner Service\n * Scans a folder and retrieves information about all .txt files\n */\n\nclass FileScannerService {\n  /**\n   * Scans a folder and returns information about all .txt files\n   * @param {string} folderPath - The path to the folder to scan\n   * @returns {Promise<Object>} JSON object containing file information\n   */\n  static async scanTextFiles(folderPath) {\n    try {\n      // Validate folder path\n      if (!folderPath || typeof folderPath !== 'string') {\n        throw new Error('Invalid folder path provided');\n      }\n\n      // Ensure folder path ends with slash\n      const normalizedPath = folderPath.endsWith('/') ? folderPath : folderPath + '/';\n\n      // Get text files from the folder\n      const files = await FileScannerService.getTextFilesFromFolder(normalizedPath);\n\n      return {\n        success: true,\n        data: {\n          folderPath: normalizedPath,\n          totalFiles: files.length,\n          files: files,\n          scanTimestamp: new Date().toISOString()\n        },\n        metadata: {\n          scanMethod: 'folder-scan',\n          environment: 'browser'\n        }\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          type: error.name,\n          timestamp: new Date().toISOString()\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Gets text files from a folder using a predefined list or server endpoint\n   * @param {string} folderPath - The folder path\n   * @returns {Promise<Array>} Array of file information objects\n   */\n  static async getTextFilesFromFolder(folderPath) {\n    // For browser environments, we'll use a predefined list or fetch from a manifest\n    const knownTextFiles = [\n      {\n        path: `${folderPath}example.txt`,\n        title: 'Example Text File',\n        info: 'Sample text file for testing the TextFileReaderService'\n      },\n      {\n        path: `${folderPath}README.txt`,\n        title: 'README File',\n        info: 'Project documentation and setup instructions'\n      }\n    ];\n\n    // Try to get additional files from a manifest\n    try {\n      const manifestResponse = await fetch(`${folderPath}file-manifest.json`);\n      if (manifestResponse.ok) {\n        const manifest = await manifestResponse.json();\n        return manifest.textFiles || knownTextFiles;\n      }\n    } catch (error) {\n      console.warn('Could not fetch file manifest, using default list');\n    }\n\n    return knownTextFiles;\n  }\n\n  /**\n   * Gets detailed information about a specific text file\n   * @param {string} filePath - Path to the text file\n   * @returns {Promise<Object>} Detailed file information\n   */\n  static async getFileInfo(filePath) {\n    try {\n      if (!filePath || typeof filePath !== 'string') {\n        throw new Error('Invalid file path provided');\n      }\n\n      if (!filePath.toLowerCase().endsWith('.txt')) {\n        throw new Error('File must have .txt extension');\n      }\n\n      // Get file content for analysis\n      const contentResponse = await fetch(filePath);\n      if (!contentResponse.ok) {\n        throw new Error(`Failed to access file: ${contentResponse.status} ${contentResponse.statusText}`);\n      }\n      \n      const content = await contentResponse.text();\n\n      // Extract title from first line or filename\n      const lines = content.split('\\n');\n      const firstLine = lines[0].trim();\n      const fileName = filePath.split('/').pop().replace('.txt', '');\n      \n      // Try to extract title from first line if it looks like a title\n      const title = this.extractTitle(firstLine, fileName);\n\n      // Generate info from content analysis\n      const info = this.generateFileInfo(content, fileName);\n\n      return {\n        success: true,\n        data: {\n          path: filePath,\n          title: title,\n          info: info,\n          fileName: fileName,\n          fileSize: content.length,\n          lineCount: lines.length,\n          wordCount: content.trim().split(/\\s+/).filter(word => word.length > 0).length,\n          characterCount: content.length,\n          firstLine: firstLine,\n          content: content,\n          timestamp: new Date().toISOString()\n        }\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: {\n          message: error.message,\n          type: error.name,\n          timestamp: new Date().toISOString()\n        },\n        data: null\n      };\n    }\n  }\n\n  /**\n   * Extracts a title from the first line or filename\n   * @param {string} firstLine - First line of the file\n   * @param {string} fileName - Name of the file without extension\n   * @returns {string} Extracted title\n   */\n  static extractTitle(firstLine, fileName) {\n    // If first line looks like a title (not too long, starts with capital, no special chars)\n    if (firstLine && \n        firstLine.length < 100 && \n        firstLine.length > 0 &&\n        /^[A-Z]/.test(firstLine) &&\n        !firstLine.includes('http') &&\n        !firstLine.includes('www')) {\n      return firstLine;\n    }\n    \n    // Otherwise use filename converted to title case\n    return fileName\n      .split(/[-_\\s]+/)\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  }\n\n  /**\n   * Generates file information based on content analysis\n   * @param {string} content - File content\n   * @param {string} fileName - File name\n   * @returns {string} Generated file information\n   */\n  static generateFileInfo(content, fileName) {\n    const lines = content.split('\\n');\n    const words = content.trim().split(/\\s+/).filter(word => word.length > 0);\n    \n    let info = '';\n    \n    if (lines.length <= 1) {\n      info = 'Single line text file';\n    } else if (lines.length <= 10) {\n      info = `Short story with ${lines.length} lines`;\n    } else if (lines.length <= 50) {\n      info = `Medium story with ${lines.length} lines`;\n    } else {\n      info = `Long story with ${lines.length} lines`;\n    }\n    \n    info += ` (${words.length} words)`;\n    \n    // Add content type hints\n    if (content.includes('http') || content.includes('www')) {\n      info += ' - Contains links';\n    }\n    if (content.includes('@')) {\n      info += ' - Contains email addresses';\n    }\n    if (content.match(/\\d{4}-\\d{2}-\\d{2}/)) {\n      info += ' - Contains dates';\n    }\n    \n    return info;\n  }\n}\n\n// Export the service\nexport default FileScannerService;\n\n// Also export individual methods for convenience\nexport const { \n  scanTextFiles, \n  getFileInfo\n} = FileScannerService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}